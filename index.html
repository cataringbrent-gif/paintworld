<!DOCTYPE html>
<!-- saved from url=(0046)file:///C:/Users/brent/maptiler-map/index.html -->
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-16LE">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapTiler Grid Overlay</title>
    <!-- Use CDN for MapLibre GL JS and CSS -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet">
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    <!-- Supabase client -->
    <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
    <script>
        // Hardcoded Supabase configuration
        window.SUPABASE_URL = 'https://bfyuaujkbzqaqyhzdbxz.supabase.co';
        window.SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJmeXVhdWprYnpxYXF5aHpkYnh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU5MTcyNzcsImV4cCI6MjA3MTQ5MzI3N30.904S0Y_EAUCR3XJVOun2qYB-3F__yQVBm970xfB8nrc';
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* Blue rounded rectangle in top right */
        .blue-rectangle {
            position: fixed;
            top: 24px;
            right: 24px;
            width: 220px;
            height: 100px;
            background: rgba(255,255,255,0.85);
            border: 2.5px solid #3498ff;
            border-radius: 18px;
            box-shadow: 0 2px 12px rgba(52,152,255,0.08);
            z-index: 1200;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .username-label {
            font-size: 1.25rem;
            color: #3498ff;
            font-weight: 700;
            letter-spacing: 1px;
            user-select: text;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
        }
        
        #map {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        

        /* Search bar styles */
        .search-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            width: 300px;
        }

        .search-box {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            font-size: 14px;
            outline: none;
            transition: box-shadow 0.2s ease;
        }

        .search-box:focus {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-top: 4px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .search-result {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover {
            background-color: #f8f9fa;
        }

        .search-result .place-name {
            font-weight: 500;
            color: #333;
            margin-bottom: 2px;
        }

        .search-result .place-details {
            font-size: 12px;
            color: #666;
        }

        .loading {
            padding: 12px 16px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        /* Hide MapTiler attribution and other map controls */
        .maplibregl-ctrl-attrib {
            display: none !important;
        }
        
        .maplibregl-ctrl-attrib-button {
            display: none !important;
        }
        
        .maplibregl-ctrl-bottom-right {
            display: none !important;
        }
        
        .maplibregl-ctrl-bottom-left {
            display: none !important;
        }

        /* Palette button and color palette styles */
        .palette-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: none;
            padding: 20px 32px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 200px;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .palette-button:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateX(-50%) translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
            border-color: rgba(0, 0, 0, 0.1);
        }

        .palette-button:active {
            transform: translateX(-50%) translateY(-2px);
        }

        .palette-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .cell-counter {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .notification.show {
            opacity: 1;
        }

        /* Zoom hint button (top-center) */
        .zoom-hint {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1600;
            display: none;
        }
        .zoom-hint button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 999px;
            background: rgba(255,255,255,0.92);
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            color: #2b425c;
            font-weight: 700;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }
        .zoom-hint button:hover { filter: brightness(1.02); }
        .zoom-hint .icon { font-size: 16px; }

        .color-palette {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 16px 20px;
            display: none;
            flex-direction: column;
            gap: 12px;
            margin: 0 20px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .color-palette.visible {
            display: flex;
        }

        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .palette-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .palette-close {
            background: rgba(0, 0, 0, 0.1);
            color: #666;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .palette-close:hover {
            background: rgba(0, 0, 0, 0.2);
        }



        .color-swatches-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 5px 0;
        }

        .color-row {
            display: flex;
            flex-direction: row;
            gap: 12px;
            justify-content: space-evenly;
            width: 100%;
        }

        .paint-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
            min-width: 180px;
        }

        .paint-button:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .paint-button:active {
            transform: translateX(-50%) translateY(0);
        }



        .color-palette.visible {
            display: flex;
        }

        .color-swatch {
            width: 52px;
            height: 52px;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .color-swatch:hover {
            transform: scale(1.15);
            border-color: rgba(0, 0, 0, 0.3);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .color-swatch.selected {
            border-color: #667eea;
            border-width: 4px;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .color-swatch.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        /* Pixel info card (bottom-center) */
        .pixel-info {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: none;
        }

        .pixel-card {
            background: #fff;
            color: #1f2a37;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(16, 24, 40, 0.15);
            border: 1px solid rgba(16, 24, 40, 0.08);
            padding: 14px 16px;
            min-width: 320px;
            max-width: 540px;
        }

        .pixel-header { display: flex; align-items: center; gap: 10px; }
        .pixel-icon { width: 18px; height: 18px; color: #3b82f6; }
        .pixel-title { font-weight: 700; font-size: 15px; color: #111827; flex: 1; }
        .pixel-close {
            background: rgba(0, 0, 0, 0.06);
            color: #4b5563;
            border: none;
            width: 28px; height: 28px;
            border-radius: 50%;
            cursor: pointer; font-size: 16px; font-weight: 700;
            display: flex; align-items: center; justify-content: center;
            transition: background .2s ease;
        }
        .pixel-close:hover { background: rgba(0, 0, 0, 0.12); }

        .pixel-owner { margin-top: 6px; display: flex; align-items: center; gap: 8px; color: #4b5563; font-weight: 600; }
        .pixel-owner .label { color: #6b7280; font-weight: 600; }
        .pixel-avatar { width: 18px; height: 18px; border-radius: 4px; object-fit: cover; background:#e5e7eb; }
        .pixel-owner-name { color: #2563eb; font-weight: 700; cursor: default; }

        .pixel-actions { margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap; }
        .btn-chip { border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 24px; background:#fff; color:#1f2a37; font-weight:700; display:flex; gap:6px; align-items:center; cursor:pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
        .btn-chip:hover { background:#f9fafb; }
        .btn-primary { background: linear-gradient(180deg, #3b82f6, #2563eb); color:#fff; border: none; box-shadow: 0 4px 12px rgba(37,99,235,0.25); }
        .btn-primary:hover { filter: brightness(1.02); }

        /* Supabase Config Modal */
        .sb-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }
        .sb-modal-card {
            width: 92%;
            max-width: 560px;
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.18);
            padding: 20px 20px 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .sb-modal-card h3 { margin: 0 0 6px 0; }
        .sb-field { display: flex; flex-direction: column; gap: 6px; }
        .sb-input { padding: 10px 12px; border: 1px solid #e3e6eb; border-radius: 8px; font-size: 14px; }
        .sb-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 8px; }
        .sb-btn { padding: 10px 14px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
        .sb-btn.primary { background: #2f9e44; color: white; }
        .sb-btn.secondary { background: #f1f3f5; color: #333; }
        
        /* Auth UI */
        #userBox {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 1500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #loginButton {
            padding: 10px 14px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            background: #3498ff;
            color: #fff;
            box-shadow: 0 2px 10px rgba(52,152,255,0.25);
        }
        #profilePic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: none;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        }
        #profileDropdown {
            position: absolute;
            top: 56px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 10px;
            background: #fff;
            border: 1px solid #e8e8e8;
            border-radius: 12px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.12);
            padding: 12px;
            min-width: 220px;
        }
        #dropdownHeader { display: flex; align-items: center; gap: 10px; }
        #dropdownProfilePic { width: 32px; height: 32px; border-radius: 50%; }
        #dropdownUsername { font-weight: 700; }
        #logoutButton {
            padding: 10px 12px; border: none; border-radius: 10px; cursor: pointer;
            background: #f1f3f5; color: #333; font-weight: 700;
        }

        /* Auth Prompt Modal */
        .auth-modal { display: none; position: fixed; inset: 0; z-index: 3500; background: rgba(0,0,0,0.35); align-items: center; justify-content: center; }
        .auth-card { background: #fff; border-radius: 16px; padding: 20px; width: 92%; max-width: 460px; box-shadow: 0 10px 40px rgba(0,0,0,0.18); display: flex; flex-direction: column; gap: 12px; }
        .google-btn { padding: 12px 14px; border: none; border-radius: 10px; cursor: pointer; font-weight: 700; background: #fff; color: #333; border: 1px solid #e3e6eb; display: flex; align-items: center; gap: 10px; justify-content: center; }

        /* Store & Pigments UI */
        .currency-pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.9); border: 1px solid #e5e7eb; margin-left: 10px; box-shadow: 0 6px 18px rgba(0,0,0,0.06); }
        .currency-pill .icon { font-size: 16px; }
        .currency-pill .pill-plus { width: 20px; height: 20px; border-radius: 50%; border: 1px solid #d1d5db; background: #fff; cursor: pointer; line-height: 18px; font-weight: 700; }
        .store-btn { margin-left: 10px; padding: 8px 12px; border-radius: 12px; border: 1px solid #e5e7eb; background: #fff; cursor: pointer; font-weight: 700; box-shadow: 0 6px 18px rgba(0,0,0,0.06); }

        .store-modal { display: none; position: fixed; inset: 0; z-index: 3400; background: rgba(0,0,0,0.45); align-items: center; justify-content: center; }
        .store-card { width: 96%; max-width: 720px; height: auto; max-height: none; overflow: visible; background: #fff; border-radius: 16px; padding: 32px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); }
        .store-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; }
        .store-title { display: flex; align-items: center; gap: 8px; font-size: 18px; font-weight: 600; color: #1e293b; }
        .store-title svg { color: #3b82f6; }
        .store-header-right { display: flex; align-items: center; gap: 12px; }
        .store-close { border: none; background: none; font-size: 20px; cursor: pointer; padding: 8px; border-radius: 6px; color: #64748b; }
        .store-close:hover { background: #f1f5f9; }
        .store-balance { display: flex; align-items: center; gap: 6px; background: #3b82f6; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 500; }
        .store-balance svg { color: white; }
        .pigments-plus-btn { width: 20px; height: 20px; border-radius: 50%; border: none; background: rgba(255,255,255,0.2); color: white; cursor: pointer; font-size: 12px; font-weight: 600; display: flex; align-items: center; justify-content: center; margin-left: 4px; }
        .pigments-plus-btn:hover { background: rgba(255,255,255,0.3); }
        
        .store-section { margin-bottom: 32px; }
        .section-header { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .section-dot { width: 8px; height: 8px; background: #3b82f6; border-radius: 50%; }
        .section-title { font-size: 16px; font-weight: 600; color: #1e293b; }
        .section-subtitle { margin: 0 0 20px 16px; font-size: 14px; color: #64748b; }
        
        .items-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .item-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; padding: 28px; text-align: center; min-height: 280px; display: flex; flex-direction: column; justify-content: space-between; }
        .item-icon { width: 48px; height: 48px; background: #e0f2fe; border-radius: 12px; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px; }
        .item-icon svg { color: #0284c7; }
        .item-card h4 { margin: 0 0 8px 0; font-size: 15px; font-weight: 600; color: #1e293b; }
        .item-card p { margin: 0 0 16px 0; font-size: 13px; color: #64748b; line-height: 1.4; }
        .qty-controls { display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 16px; }
        .qty-btn { width: 28px; height: 28px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer; font-size: 14px; color: #6b7280; display: flex; align-items: center; justify-content: center; }
        .qty-btn:hover { border-color: #9ca3af; }
        .qty-input { width: 50px; height: 28px; text-align: center; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; background: white; }
        .item-price { display: flex; align-items: center; justify-content: center; gap: 4px; margin-bottom: 16px; font-size: 14px; font-weight: 500; color: #64748b; }
        .item-price svg { color: #3b82f6; }
        .purchase-btn { width: 100%; padding: 10px 16px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; }
        .purchase-btn:disabled { background: #e2e8f0; color: #94a3b8; cursor: not-allowed; }
        .purchase-btn:hover:not(:disabled) { background: #2563eb; }
        
        .border-section { margin-top: 32px; }
        .border-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; padding: 32px; text-align: center; min-height: 320px; display: flex; flex-direction: column; justify-content: space-between; }
        .border-icon { width: 64px; height: 64px; background: #dbeafe; border-radius: 16px; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px; }
        .border-icon svg { color: #3b82f6; }
        .border-card h4 { margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #1e293b; }
        .border-card p { margin: 0 0 24px 0; font-size: 14px; color: #64748b; }
        .border-inputs { display: flex; gap: 16px; justify-content: center; margin-bottom: 20px; }
        .input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .input-group label { font-size: 13px; color: #64748b; font-weight: 500; }
        .input-group input { width: 100px; height: 44px; text-align: center; border: 1px solid #d1d5db; border-radius: 8px; font-size: 16px; background: white; }
        .border-payment-buttons { display: flex; gap: 12px; margin-bottom: 20px; }
        .border-payment-btn { flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; background: white; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .border-payment-btn:hover:not(:disabled) { border-color: #3b82f6; background: #f8fafc; }
        .border-payment-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .pigments-btn { color: #3b82f6; }
        .usd-btn { color: #059669; }

        .pigments-modal { display: none; position: fixed; inset: 0; z-index: 3500; background: rgba(0,0,0,0.45); align-items: center; justify-content: center; }
        .pigments-card { width: 96%; max-width: 640px; height: auto; max-height: none; overflow: visible; background: #fff; border-radius: 24px; padding: 32px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); }
        .pigments-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
        .pigments-header-right { display: flex; align-items: center; gap: 12px; }
        .pigments-title { display: flex; align-items: center; gap: 8px; font-size: 20px; font-weight: 600; color: #1e293b; }
        .pigments-balance-pill { display: flex; align-items: center; gap: 6px; background: #3b82f6; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 500; }
        .pigments-balance-pill svg { color: white; }
        .pigments-close { border: none; background: none; font-size: 20px; cursor: pointer; padding: 8px; border-radius: 6px; color: #64748b; }
        .pigments-close:hover { background: #f1f5f9; }
        .pigments-subtitle { margin: 0 0 24px 0; font-size: 14px; color: #64748b; }
        .tiers { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; }
        .tier { background: #e0f2fe; border-radius: 16px; padding: 24px; text-align: center; }
        .tier-pigment { color: #3b82f6; font-size: 24px; margin-bottom: 8px; }
        .tier-amount { font-size: 28px; font-weight: 700; color: #3b82f6; margin: 0; }
        .tier-unit { font-size: 16px; color: #3b82f6; font-weight: 500; }
        .tier-bonus { font-size: 13px; color: #64748b; margin: 8px 0 16px 0; }
        .tier-price { width: 100%; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; }
        .tier-price:hover { background: #2563eb; }
    </style>
</head>
<body>
    <!-- Supabase Config Modal -->
    <div id="supabaseConfigModal" class="sb-modal">
      <div class="sb-modal-card">
        <h3>Configure Supabase</h3>
        <div class="sb-field">
          <label for="sbUrlInput">Project URL</label>
          <input id="sbUrlInput" class="sb-input" placeholder="https://YOUR_PROJECT.supabase.co" />
        </div>
        <div class="sb-field">
          <label for="sbKeyInput">Anon Key</label>
          <input id="sbKeyInput" class="sb-input" placeholder="eyJhbGciOi..." />
        </div>
        <div class="sb-actions">
          <button id="sbCancelBtn" class="sb-btn secondary">Cancel</button>
          <button id="sbSaveBtn" class="sb-btn primary">Save</button>
        </div>
      </div>
    </div>

    <!-- Auth/User Box -->
    <div id="userBox" style="display:flex;">
        <button id="loginButton" title="Log in">Log In</button>
        <img id="profilePic" alt="Profile"/>
        <!-- Pigments currency pill (only when logged in) -->
        <div id="pigmentsPill" class="currency-pill" style="display:none;">
            <span class="icon">🎨</span>
            <span id="pigmentsCount">0</span>
            <button id="pigmentsPlus" class="pill-plus" title="Get pigments">+</button>
        </div>
        <!-- Store button (only when logged in) -->
        <button id="storeButton" class="store-btn" style="display:none;">🛍️ Store</button>
        <div id="profileDropdown">
            <div id="dropdownHeader">
                <img id="dropdownProfilePic" alt="Profile"/>
                <span id="dropdownUsername"></span>
            </div>
            <button id="logoutButton">Log out</button>
        </div>
    </div>

    <!-- Auth Prompt Modal (shown when clicking Paint while signed out) -->
    <div id="authPromptModal" class="auth-modal">
      <div class="auth-card">
        <h3>Sign in to paint</h3>
        <button id="googleSignInBtn" class="google-btn">Sign in with Google</button>
        <button id="authCancelBtn" class="sb-btn secondary" style="align-self:flex-end;">Cancel</button>
      </div>
    </div>

    <!-- Store Modal -->
    <div id="storeModal" class="store-modal">
      <div class="store-card">
        <div class="store-header">
          <div class="store-title">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 3h2l.4 2M7 13h10l4-8H5.4m1.6 8L6 6H2m5 7v6a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-6m-9 0h10"/>
            </svg>
            <span>Store</span>
          </div>
          <div class="store-header-right">
            <div class="store-balance">
              <span>🎨</span>
              <span id="storePigmentsBalance">0</span>
              <span>Pigments</span>
              <button class="pigments-plus-btn" id="pigmentsPlusBtn">+</button>
            </div>
            <button id="storeClose" class="store-close">×</button>
          </div>
        </div>
        
        <div class="store-section">
          <div class="section-header">
            <div class="section-dot"></div>
            <span class="section-title">Items</span>
          </div>
          <p class="section-subtitle">Get more charges</p>
          
          <div class="items-grid">
            <div class="item-card" id="itemCapacity">
              <div class="item-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 19V5M5 12l7-7 7 7"/>
                </svg>
              </div>
              <h4>+5 Max. Charges</h4>
              <p>Increase your maximum paint charges capacity</p>
              <div class="qty-controls">
                <button class="qty-btn" id="capMinus">−</button>
                <input class="qty-input" id="capQty" type="number" value="1" min="1" />
                <button class="qty-btn" id="capPlus">+</button>
              </div>
              <div class="item-price">
                <span>🎨</span>
                <span id="capCost">500</span>
                <span>Pigments</span>
              </div>
              <button id="buyCapacity" class="purchase-btn" disabled>Purchase</button>
            </div>
            
            <div class="item-card" id="itemCharges">
              <div class="item-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
                </svg>
              </div>
              <h4>+30 Paint Charges</h4>
              <p>Recharge paint charges</p>
              <div class="qty-controls">
                <button class="qty-btn" id="chgMinus">−</button>
                <input class="qty-input" id="chgQty" type="number" value="1" min="1" />
                <button class="qty-btn" id="chgPlus">+</button>
              </div>
              <div class="item-price">
                <span>🎨</span>
                <span id="chgCost">300</span>
                <span>Pigments</span>
              </div>
              <button id="buyCharges" class="purchase-btn" disabled>Purchase</button>
            </div>
          </div>
        </div>

        <div class="border-section">
          <div class="border-card">
            <div class="border-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <rect x="7" y="7" width="10" height="10"/>
              </svg>
            </div>
            <h4>Border</h4>
            <p>Protect your art from griefers</p>
            
            <div class="border-inputs">
              <div class="input-group">
                <label>Width:</label>
                <input id="borderWidth" type="number" value="10" min="1" max="100" />
              </div>
              <div class="input-group">
                <label>Height:</label>
                <input id="borderHeight" type="number" value="10" min="1" max="100" />
              </div>
            </div>
            
            <div class="border-payment-buttons">
              <button id="buyBorderPigments" class="border-payment-btn pigments-btn" disabled>
                <span>🎨</span>
                <span id="borderPigmentsCost">800</span>
                <span>Pigments</span>
              </button>
              <button id="buyBorderUSD" class="border-payment-btn usd-btn" disabled>
                <span>$</span>
                <span id="borderUSDCost">0.10</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Pigments Purchase Modal (money) -->
    <div id="pigmentsModal" class="pigments-modal">
      <div class="pigments-card">
        <div class="pigments-header">
          <div class="pigments-title">
            <span>🎨</span>
            <span>Pigments</span>
          </div>
          <div class="pigments-header-right">
            <div class="pigments-balance-pill">
              <span>🎨</span>
              <span id="pigmentsModalBalance">0</span>
              <span>Pigments</span>
            </div>
            <button id="pigmentsClose" class="pigments-close">×</button>
          </div>
        </div>
        <p class="pigments-subtitle">You gain 1 pigment per pixel painted and 500 pigments per level</p>
        <div class="tiers">
          <div class="tier">
            <div class="tier-pigment">🎨</div>
            <div class="tier-amount">25,000</div>
            <div class="tier-unit">Pigments</div>
            <div class="tier-bonus">+0 bonus</div>
            <button class="tier-price" data-amt="500">$5.00</button>
          </div>
          <div class="tier">
            <div class="tier-pigment">🎨</div>
            <div class="tier-amount">78,750</div>
            <div class="tier-unit">Pigments</div>
            <div class="tier-bonus">75,000 Pigments +3,750 bonus</div>
            <button class="tier-price" data-amt="1500">$15.00</button>
          </div>
          <div class="tier">
            <div class="tier-pigment">🎨</div>
            <div class="tier-amount">165,000</div>
            <div class="tier-unit">Pigments</div>
            <div class="tier-bonus">150,000 Pigments +15,000 bonus</div>
            <button class="tier-price" data-amt="3000">$30.00</button>
          </div>
          <div class="tier">
            <div class="tier-pigment">🎨</div>
            <div class="tier-amount">287,500</div>
            <div class="tier-unit">Pigments</div>
            <div class="tier-bonus">250,000 Pigments +37,500 bonus</div>
            <button class="tier-price" data-amt="5000">$50.00</button>
          </div>
          <div class="tier">
            <div class="tier-pigment">🎨</div>
            <div class="tier-amount">450,000</div>
            <div class="tier-unit">Pigments</div>
            <div class="tier-bonus">375,000 Pigments +75,000 bonus</div>
            <button class="tier-price" data-amt="7500">$75.00</button>
          </div>
          <div class="tier">
            <div class="tier-pigment">🎨</div>
            <div class="tier-amount">625,000</div>
            <div class="tier-unit">Pigments</div>
            <div class="tier-bonus">500,000 Pigments +125,000 bonus</div>
            <button class="tier-price" data-amt="10000">$100.00</button>
          </div>
        </div>
      </div>
    </div>

    <div id="map" class="maplibregl-map"><div class="maplibregl-canvas-container maplibregl-interactive maplibregl-touch-drag-pan maplibregl-touch-zoom-rotate"><canvas class="maplibregl-canvas" tabindex="0" aria-label="Map" role="region" width="1912" height="954" style="width: 1912px; height: 954px;"></canvas></div><div class="maplibregl-control-container"><div class="maplibregl-ctrl-top-left "></div><div class="maplibregl-ctrl-top-right "></div><div class="maplibregl-ctrl-bottom-left "></div><div class="maplibregl-ctrl-bottom-right "><details class="maplibregl-ctrl maplibregl-ctrl-attrib" open=""><summary class="maplibregl-ctrl-attrib-button" title="Toggle attribution" aria-label="Toggle attribution"></summary><div class="maplibregl-ctrl-attrib-inner"><a href="https://www.maptiler.com/copyright/" target="_blank"> MapTiler</a> <a href="https://www.openstreetmap.org/copyright" target="_blank"> OpenStreetMap contributors</a></div></details></div></div></div>
    
    <!-- Search bar -->
    <div class="search-container">
        <input type="text" class="search-box" placeholder="Search for a place..." id="searchInput">
        <div class="search-results" id="searchResults" style="display: none;"></div>
    </div>
    
    
    
    <!-- Zoom hint button (shown only when > 4000 x 4000 cells are visible) -->
    <div class="zoom-hint" id="zoomHint"><button id="zoomHintBtn"><span class="icon">↔️</span>Zoom in to see the pixels</button></div>
    
    <!-- Notification bar disabled -->
    <div class="notification" id="notification" style="display:none;">No more charges</div>
    
    <!-- Paint button -->
    <button class="paint-button" id="paintButton" style="display:flex; align-items:center; justify-content:center; background:#3498ff; color:#fff; border:none; border-radius:24px; padding:14px 24px; font-size:1.25rem; font-weight:700; box-shadow:0 2px 12px rgba(52,152,255,0.18); cursor:pointer; min-width:120px; gap:8px;">
    <span style="font-size:1.3em; margin-right:6px;">🖌️</span>
        <span id="paintButtonText">Paint</span>
    </button>

    <!-- Pixel info card (shown when user clicks a cell) -->
    <div class="pixel-info" id="pixelInfo" style="display:none;">
      <div class="pixel-card">
        <div class="pixel-header">
          <span class="pixel-icon">📍</span>
          <div class="pixel-title" id="pixelInfoText">Pixel: 0, 0</div>
          <button class="pixel-close" id="pixelClose">×</button>
        </div>
        <div class="pixel-owner" id="pixelOwnerRow" style="display:flex;">
          <span class="label">Painted by:</span>
          <img class="pixel-avatar" id="pixelOwnerAvatar" src="" alt="" style="display:none;" />
          <span class="pixel-owner-name" id="pixelOwnerText">Unpainted</span>
        </div>
        <div class="pixel-actions">
          <button class="btn-chip btn-primary" id="pixelActionPaint">🖌️ Paint</button>
          <button class="btn-chip" id="pixelActionFavorite">☆ Favorite</button>
          <button class="btn-chip" id="pixelActionShare">↗ Share</button>
        </div>
      </div>
    </div>

    <!-- Color palette -->
    <div class="color-palette" id="colorPalette">
        <div class="palette-header">
            <div class="palette-title">
                <span>⬜</span>
                <span>Paint pixel (1)</span>
            </div>
            <button class="palette-close" id="paletteClose">×</button>
        </div>
        <div class="color-swatches-container" id="colorSwatchesContainer">
            <div class="color-row" id="colorRow1"><div class="color-swatch" data-color="#6D001A" style="background-color: rgb(109, 0, 26);"></div><div class="color-swatch" data-color="#BE0039" style="background-color: rgb(190, 0, 57);"></div><div class="color-swatch" data-color="#FF4500" style="background-color: rgb(255, 69, 0);"></div><div class="color-swatch" data-color="#FFA800" style="background-color: rgb(255, 168, 0);"></div><div class="color-swatch" data-color="#FFD635" style="background-color: rgb(255, 214, 53);"></div><div class="color-swatch" data-color="#FFF8B8" style="background-color: rgb(255, 248, 184);"></div><div class="color-swatch" data-color="#00A368" style="background-color: rgb(0, 163, 104);"></div><div class="color-swatch" data-color="#00CC78" style="background-color: rgb(0, 204, 120);"></div><div class="color-swatch" data-color="#7EED56" style="background-color: rgb(126, 237, 86);"></div><div class="color-swatch selected" data-color="#00756F" style="background-color: rgb(0, 117, 111);"></div><div class="color-swatch" data-color="#009EAA" style="background-color: rgb(0, 158, 170);"></div><div class="color-swatch" data-color="#00CCC0" style="background-color: rgb(0, 204, 192);"></div><div class="color-swatch" data-color="#2450A4" style="background-color: rgb(36, 80, 164);"></div><div class="color-swatch" data-color="#3690EA" style="background-color: rgb(54, 144, 234);"></div><div class="color-swatch" data-color="#51E9F4" style="background-color: rgb(81, 233, 244);"></div><div class="color-swatch" data-color="#493AC1" style="background-color: rgb(73, 58, 193);"></div><div class="color-swatch" data-color="#6A5CFF" style="background-color: rgb(106, 92, 255);"></div><div class="color-swatch" data-color="#811E9F" style="background-color: rgb(129, 30, 159);"></div><div class="color-swatch" data-color="#B44AC0" style="background-color: rgb(180, 74, 192);"></div><div class="color-swatch" data-color="#FF3881" style="background-color: rgb(255, 56, 129);"></div></div>
            <div class="color-row" id="colorRow2"><div class="color-swatch" data-color="#FF99AA" style="background-color: rgb(255, 153, 170);"></div><div class="color-swatch" data-color="#6D482F" style="background-color: rgb(109, 72, 47);"></div><div class="color-swatch" data-color="#9C6926" style="background-color: rgb(156, 105, 38);"></div><div class="color-swatch" data-color="#FFB470" style="background-color: rgb(255, 180, 112);"></div><div class="color-swatch" data-color="#000000" style="background-color: rgb(0, 0, 0);"></div><div class="color-swatch" data-color="#515252" style="background-color: rgb(81, 82, 82);"></div><div class="color-swatch" data-color="#898D90" style="background-color: rgb(137, 141, 144);"></div><div class="color-swatch" data-color="#D4D7D9" style="background-color: rgb(212, 215, 217);"></div><div class="color-swatch" data-color="#FFFFFF" style="background-color: rgb(255, 255, 255);"></div><div class="color-swatch" data-color="#FF6B6B" style="background-color: rgb(255, 107, 107);"></div><div class="color-swatch" data-color="#4ECDC4" style="background-color: rgb(78, 205, 196);"></div><div class="color-swatch" data-color="#45B7D1" style="background-color: rgb(69, 183, 209);"></div><div class="color-swatch" data-color="#96CEB4" style="background-color: rgb(150, 206, 180);"></div><div class="color-swatch" data-color="#FFEAA7" style="background-color: rgb(255, 234, 167);"></div><div class="color-swatch" data-color="#DDA0DD" style="background-color: rgb(221, 160, 221);"></div><div class="color-swatch" data-color="#98D8C8" style="background-color: rgb(152, 216, 200);"></div><div class="color-swatch" data-color="#F7DC6F" style="background-color: rgb(247, 220, 111);"></div><div class="color-swatch" data-color="#BB8FCE" style="background-color: rgb(187, 143, 206);"></div><div class="color-swatch" data-color="#85C1E9" style="background-color: rgb(133, 193, 233);"></div><div class="color-swatch" data-color="#F8C471" style="background-color: rgb(248, 196, 113);"></div></div>
        </div>
    </div>
    
            <script>
            // ================= Supabase-backed persistence (polling until Realtime available) =================
            // Config helpers: read from query params once then persist to localStorage. Anon key is public.
            (function bootstrapSupabaseConfig(){
              const params = new URLSearchParams(window.location.search);
              const url = params.get('supabaseUrl');
              const key = params.get('supabaseKey');
              if (url && key) {
                localStorage.setItem('supabase_url', url);
                localStorage.setItem('supabase_anon_key', key);
                // Clean URL params without reloading
                const clean = new URL(window.location.href);
                clean.searchParams.delete('supabaseUrl');
                clean.searchParams.delete('supabaseKey');
                window.history.replaceState({}, '', clean.toString());
              }
            })();

            function getSupabaseConfig() {
              const url = localStorage.getItem('supabase_url') || window.SUPABASE_URL;
              const key = localStorage.getItem('supabase_anon_key') || window.SUPABASE_ANON_KEY;
              return { url, key };
            }

            const cfg = getSupabaseConfig();
            if (!cfg?.url || !cfg?.key || typeof window.supabase === 'undefined') {
              // Show config modal to collect details, then reload
              const modal = document.getElementById('supabaseConfigModal');
              const urlEl = document.getElementById('sbUrlInput');
              const keyEl = document.getElementById('sbKeyInput');
              const saveBtn = document.getElementById('sbSaveBtn');
              const cancelBtn = document.getElementById('sbCancelBtn');
              if (modal) {
                modal.style.display = 'flex';
                // Prefill from any existing values
                if (cfg?.url) urlEl.value = cfg.url;
                if (cfg?.key) keyEl.value = cfg.key;
                saveBtn.onclick = () => {
                  const u = (urlEl.value || '').trim();
                  const k = (keyEl.value || '').trim();
                  if (!u || !k) return;
                  localStorage.setItem('supabase_url', u);
                  localStorage.setItem('supabase_anon_key', k);
                  window.location.reload();
                };
                cancelBtn.onclick = () => { modal.style.display = 'none'; };
              }
              console.warn('Supabase not configured. Enter your details to continue.');
            }

            const supabase = (cfg?.url && cfg?.key && window.supabase)
              ? window.supabase.createClient(cfg.url, cfg.key)
              : null;

            // Current user info (from Supabase auth)
            let USER_ID = null;
            let USER_NAME = null;
            let USER_AVATAR = null;

            // Per-user paint charges
            const DEFAULT_CAPACITY = 100;
            const DEFAULT_CHARGES = 100;
            const RECHARGE_SECONDS = 30; // 1 charge per 30s when not full
            let USER_CAPACITY = DEFAULT_CAPACITY;
            let USER_CHARGES = DEFAULT_CHARGES;
            // Pigments currency (🎨)
            let USER_PIGMENTS = 0; // stored per-user; fallback to localStorage if DB column missing
            const CAPACITY_UNIT = 5;      // +5 capacity per unit
            const CHARGES_UNIT = 30;      // +30 charges per unit
            const CAPACITY_COST = 500;    // pigments per unit
            const CHARGES_COST = 500;     // pigments per unit
            const BORDER_COST_PER_CELL = 8; // pigments per border cell
            let lastRefillAt = null; // Date (ms) anchor for regen cadence
            let regenTimer = null;

            function fmtCountdown(seconds) {
              const m = Math.floor(seconds / 60);
              const s = Math.floor(seconds % 60).toString().padStart(2, '0');
              return m > 0 ? `${m}:${s}` : `0:${s}`;
            }

            function updatePaintButtonUI() {
              const btn = document.getElementById('paintButton');
              const label = document.getElementById('paintButtonText');
              if (!btn || !label) return;
              if (!USER_ID) {
                label.textContent = 'Paint';
                return;
              }
              // Show counts always for signed-in users
              let suffix = '';
              if (USER_CHARGES < USER_CAPACITY && lastRefillAt) {
                const now = Date.now();
                const elapsed = Math.max(0, (now - lastRefillAt) / 1000);
                const nextIn = RECHARGE_SECONDS - (elapsed % RECHARGE_SECONDS);
                suffix = ` (${fmtCountdown(nextIn)})`;
              }
              label.textContent = `Paint ${USER_CHARGES}/${USER_CAPACITY}${suffix}`;
            }

            function stopRegenTimer() { if (regenTimer) { clearInterval(regenTimer); regenTimer = null; } }

            async function tickRegen() {
              if (!USER_ID) return;
              if (USER_CHARGES >= USER_CAPACITY) { lastRefillAt = null; updatePaintButtonUI(); return; }
              if (!lastRefillAt) lastRefillAt = Date.now();
              const now = Date.now();
              const deltaSec = Math.floor((now - lastRefillAt) / 1000);
              if (deltaSec < RECHARGE_SECONDS) { updatePaintButtonUI(); return; }
              const gained = Math.floor(deltaSec / RECHARGE_SECONDS);
              if (gained <= 0) { updatePaintButtonUI(); return; }
              const room = USER_CAPACITY - USER_CHARGES;
              const toAdd = Math.min(room, gained);
              if (toAdd <= 0) { updatePaintButtonUI(); return; }
              USER_CHARGES += toAdd;
              lastRefillAt += toAdd * RECHARGE_SECONDS * 1000; // slide anchor forward by whole steps
              // Persist minimal writes
              if (supabase) {
                await supabase.from('user_paints').update({
                  charges: USER_CHARGES,
                  last_refill_at: new Date(lastRefillAt).toISOString(),
                  capacity: USER_CAPACITY
                }).eq('user_id', USER_ID);
              }
              updatePaintButtonUI();
            }

            function startRegenTimer() {
              stopRegenTimer();
              regenTimer = setInterval(tickRegen, 1000);
            }

            async function loadOrInitUserPaints() {
              if (!supabase || !USER_ID) return;
              const { data, error } = await supabase
                .from('user_paints')
                .select('*')
                .eq('user_id', USER_ID)
                .maybeSingle();
              if (error) { console.warn('user_paints select error', error); }
              if (!data) {
                USER_CAPACITY = DEFAULT_CAPACITY;
                USER_CHARGES = DEFAULT_CHARGES;
                lastRefillAt = Date.now();
                await supabase.from('user_paints').insert({
                  user_id: USER_ID,
                  capacity: USER_CAPACITY,
                  charges: USER_CHARGES,
                  regen_seconds: RECHARGE_SECONDS,
                  last_refill_at: new Date(lastRefillAt).toISOString()
                });
              } else {
                USER_CAPACITY = Math.max(1, data.capacity ?? DEFAULT_CAPACITY);
                USER_CHARGES = Math.max(0, data.charges ?? DEFAULT_CHARGES); // allow > capacity
                // Use server anchor if present, but only keep it when below capacity
                const serverAnchor = data.last_refill_at ? new Date(data.last_refill_at).getTime() : null;
                lastRefillAt = (USER_CHARGES < USER_CAPACITY) ? (serverAnchor || Date.now()) : null;
                // Load pigments if column exists; else fallback local
                if (typeof data.pigments === 'number') {
                  USER_PIGMENTS = Math.max(0, data.pigments);
                } else {
                  const ls = localStorage.getItem(`pigments:${USER_ID}`);
                  USER_PIGMENTS = ls ? Math.max(0, parseInt(ls, 10) || 0) : 0;
                }
              }
              updatePaintButtonUI();
              startRegenTimer();
              updatePigmentsUI();
            }

            function updatePigmentsUI() {
              const pill = document.getElementById('pigmentsPill');
              const count = document.getElementById('pigmentsCount');
              const storeBal = document.getElementById('storePigmentsBalance');
              const pigBal = document.getElementById('pigmentsModalBalance');
              if (count) count.textContent = USER_PIGMENTS.toLocaleString();
              if (storeBal) storeBal.textContent = USER_PIGMENTS.toLocaleString();
              if (pigBal) pigBal.textContent = USER_PIGMENTS.toLocaleString();
              // Show pill if logged in
              if (pill) pill.style.display = USER_ID ? 'inline-flex' : 'none';
              // Store button visibility handled in renderAuthUI
              updateStoreButtonsEnabled();
            }

            async function persistPigments() {
              if (supabase && USER_ID) {
                try {
                  const { error } = await supabase.from('user_paints').update({ pigments: USER_PIGMENTS }).eq('user_id', USER_ID);
                  if (error) throw error;
                } catch (e) {
                  // fallback local
                  localStorage.setItem(`pigments:${USER_ID}`, String(USER_PIGMENTS));
                }
              }
            }

            function calculateBorderCostUSD(width, height) {
              // USD cost = (width * height) * 0.001
              return (width * height) * 0.001;
            }

            function calculateBorderCostPigments(width, height) {
              const usdCost = calculateBorderCostUSD(width, height);
              // Convert USD to pigments using shop rates
              // Using $5 = 25,000 pigments rate (0.0002 USD per pigment)
              return Math.ceil(usdCost / 0.0002);
            }

            function updateBorderCost() {
              const width = parseInt(document.getElementById('borderWidth')?.value || '10', 10) || 10;
              const height = parseInt(document.getElementById('borderHeight')?.value || '10', 10) || 10;
              
              const usdCost = calculateBorderCostUSD(width, height);
              const pigmentsCost = calculateBorderCostPigments(width, height);
              
              const pigmentsCostEl = document.getElementById('borderPigmentsCost');
              const usdCostEl = document.getElementById('borderUSDCost');
              
              if (pigmentsCostEl) pigmentsCostEl.textContent = pigmentsCost.toLocaleString();
              if (usdCostEl) usdCostEl.textContent = usdCost.toFixed(2);
              
              const pigmentsBtn = document.getElementById('buyBorderPigments');
              const usdBtn = document.getElementById('buyBorderUSD');
              
              if (pigmentsBtn) {
                const canAfford = USER_PIGMENTS >= pigmentsCost;
                pigmentsBtn.disabled = !canAfford;
              }
              if (usdBtn) {
                // USD button always enabled (payment processing will handle validation)
                usdBtn.disabled = false;
              }
            }

            function updateStoreButtonsEnabled() {
              const capQty = parseInt(document.getElementById('capQty')?.value || '1', 10) || 1;
              const chgQty = parseInt(document.getElementById('chgQty')?.value || '1', 10) || 1;
              const capCost = capQty * CAPACITY_COST;
              const chgCost = chgQty * CHARGES_COST;
              const capBtn = document.getElementById('buyCapacity');
              const chgBtn = document.getElementById('buyCharges');
              const capCostEl = document.getElementById('capCost');
              const chgCostEl = document.getElementById('chgCost');
              if (capCostEl) capCostEl.textContent = capCost.toLocaleString();
              if (chgCostEl) chgCostEl.textContent = chgCost.toLocaleString();
              if (capBtn) {
                const ok = USER_PIGMENTS >= capCost;
                capBtn.disabled = !ok;
              }
              if (chgBtn) {
                const ok = USER_PIGMENTS >= chgCost;
                chgBtn.disabled = !ok;
              }
              updateBorderCost();
            }

            // Store painted cells: "x,y" -> { color, owner }
            let paintedCells = new Map();
            // Helper to display short owner identifiers when names are unavailable
            function shortUser(id) { return id ? (id.length > 8 ? id.slice(0,8) + '…' : id) : 'Unknown'; }

            async function ensureAuth() {
              if (!supabase) return null;
              const { data: { user } } = await supabase.auth.getUser();
              if (user) {
                USER_ID = user.id;
                USER_NAME = user.user_metadata?.full_name || user.email || 'User';
                USER_AVATAR = user.user_metadata?.avatar_url || null;
                return user;
              }
              return null; // no auto-anon; require Google login
            }

            function renderAuthUI(user) {
              const loginBtn = document.getElementById('loginButton');
              const profilePic = document.getElementById('profilePic');
              const dropdownPic = document.getElementById('dropdownProfilePic');
              const dropdownName = document.getElementById('dropdownUsername');
              const dropdown = document.getElementById('profileDropdown');
              const storeBtn = document.getElementById('storeButton');
              const pigmentsPill = document.getElementById('pigmentsPill');
              if (!loginBtn || !profilePic || !dropdown) return;
              if (!user) {
                loginBtn.style.display = 'inline-block';
                profilePic.style.display = 'none';
                dropdown.style.display = 'none';
                if (storeBtn) storeBtn.style.display = 'none';
                if (pigmentsPill) pigmentsPill.style.display = 'none';
                return;
              }
              const pic = user.user_metadata?.avatar_url || '';
              const name = user.user_metadata?.full_name || user.email || 'User';
              loginBtn.style.display = 'none';
              if (pic) { profilePic.src = pic; dropdownPic.src = pic; }
              dropdownName.textContent = name;
              profilePic.style.display = 'block';
              if (storeBtn) storeBtn.style.display = 'inline-flex';
              if (pigmentsPill) pigmentsPill.style.display = 'inline-flex';
            }

            function showAuthPrompt() { const m = document.getElementById('authPromptModal'); if (m) m.style.display = 'flex'; }
            function hideAuthPrompt() { const m = document.getElementById('authPromptModal'); if (m) m.style.display = 'none'; }

            async function loginWithGoogle() {
              if (!supabase) return;
              await supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: window.location.origin } });
            }

            async function logout() {
              if (!supabase) return;
              await supabase.auth.signOut();
              USER_ID = null;
              USER_NAME = null;
              USER_AVATAR = null;
              stopRegenTimer();
              USER_CAPACITY = DEFAULT_CAPACITY; USER_CHARGES = DEFAULT_CHARGES; lastRefillAt = null;
              renderAuthUI(null);
              updatePaintButtonUI();
              // Close modals and reset pigments UI
              const storeModal = document.getElementById('storeModal');
              const pigmentsModal = document.getElementById('pigmentsModal');
              if (storeModal) storeModal.style.display = 'none';
              if (pigmentsModal) pigmentsModal.style.display = 'none';
              updatePigmentsUI();
            }

            function mergeRow(row) {
              const key = `${row.x},${row.y}`;
              if (row.color === null) {
                paintedCells.delete(key);
              } else {
                paintedCells.set(key, { color: row.color, owner: row.owner, owner_name: row.owner_name || null, owner_avatar: row.owner_avatar || null });
              }
            }

            async function initialLoad() {
              if (!supabase) return;
              const { data, error } = await supabase
                .from('paints')
                .select('*')
                .order('updated_at', { ascending: true });
              if (error) { console.error('Initial load error', error); return; }
              paintedCells.clear();
              for (const row of data) mergeRow(row);
              updatePaintedCellsDisplay();
              updateCellCounter();
            }

            let lastSeen = new Date(0).toISOString();
            async function pollUpdates() {
              if (!supabase) return;
              const { data, error } = await supabase
                .from('paints')
                .select('*')
                .gt('updated_at', lastSeen)
                .order('updated_at', { ascending: true });
              if (error) { console.error('Poll error', error); return; }
              if (data && data.length) {
                for (const row of data) mergeRow(row);
                lastSeen = data[data.length - 1].updated_at;
                updatePaintedCellsDisplay();
                updateCellCounter();
              }
            }

            (async function startPersistence(){
              if (!supabase) return;
              const user = await ensureAuth();
              renderAuthUI(user);
              if (user) { await loadOrInitUserPaints(); } else { updatePaintButtonUI(); }
              await initialLoad();
              // Start polling every 2s until Realtime is available
              setInterval(pollUpdates, 2000);
            })();

            // Auth UI events
            document.addEventListener('DOMContentLoaded', () => {
              const loginBtn = document.getElementById('loginButton');
              const profilePic = document.getElementById('profilePic');
              const dropdown = document.getElementById('profileDropdown');
              const logoutBtn = document.getElementById('logoutButton');
              const googleBtn = document.getElementById('googleSignInBtn');
              const authCancelBtn = document.getElementById('authCancelBtn');
              // Store & Pigments UI elements
              const storeBtn = document.getElementById('storeButton');
              const storeModal = document.getElementById('storeModal');
              const storeClose = document.getElementById('storeClose');
              const pigmentsPill = document.getElementById('pigmentsPill');
              const pigmentsPlus = document.getElementById('pigmentsPlus');
              const pigmentsModal = document.getElementById('pigmentsModal');
              const pigmentsClose = document.getElementById('pigmentsClose');

              loginBtn?.addEventListener('click', () => showAuthPrompt());
              googleBtn?.addEventListener('click', () => loginWithGoogle());
              authCancelBtn?.addEventListener('click', () => hideAuthPrompt());
              logoutBtn?.addEventListener('click', () => logout());
              profilePic?.addEventListener('click', () => {
                if (dropdown.style.display === 'flex') dropdown.style.display = 'none';
                else dropdown.style.display = 'flex';
              });
              document.addEventListener('mousedown', (e) => {
                if (dropdown.style.display === 'flex' && !dropdown.contains(e.target) && e.target !== profilePic) {
                  dropdown.style.display = 'none';
                }
              });
              storeBtn?.addEventListener('click', () => { storeModal.style.display = 'flex'; updateStoreButtonsEnabled(); updatePigmentsUI(); });
              storeClose?.addEventListener('click', () => { storeModal.style.display = 'none'; });
              pigmentsPlus?.addEventListener('click', () => { pigmentsModal.style.display = 'flex'; updatePigmentsUI(); });
              pigmentsClose?.addEventListener('click', () => { pigmentsModal.style.display = 'none'; });

              // Pigments plus button in store balance
              const pigmentsPlusBtn = document.getElementById('pigmentsPlusBtn');
              pigmentsPlusBtn?.addEventListener('click', () => { pigmentsModal.style.display = 'flex'; updatePigmentsUI(); });

              // Qty controls
              const capMinus = document.getElementById('capMinus');
              const capPlus = document.getElementById('capPlus');
              const capQty = document.getElementById('capQty');
              const chgMinus = document.getElementById('chgMinus');
              const chgPlus = document.getElementById('chgPlus');
              const chgQty = document.getElementById('chgQty');
              const borderWidth = document.getElementById('borderWidth');
              const borderHeight = document.getElementById('borderHeight');
              [capMinus, capPlus, capQty, chgMinus, chgPlus, chgQty].forEach(el => el?.addEventListener('click', updateStoreButtonsEnabled));
              capQty?.addEventListener('input', updateStoreButtonsEnabled);
              chgQty?.addEventListener('input', updateStoreButtonsEnabled);
              borderWidth?.addEventListener('input', updateBorderCost);
              borderHeight?.addEventListener('input', updateBorderCost);

              // Purchase actions
              const buyCapacity = document.getElementById('buyCapacity');
              const buyCharges = document.getElementById('buyCharges');
              buyCapacity?.addEventListener('click', async () => {
                const qty = Math.max(1, parseInt(capQty.value || '1', 10) || 1);
                const cost = qty * CAPACITY_COST;
                if (USER_PIGMENTS < cost) return;
                USER_PIGMENTS -= cost;
                USER_CAPACITY += qty * CAPACITY_UNIT;
                await supabase?.from('user_paints').update({ capacity: USER_CAPACITY }).eq('user_id', USER_ID);
                await persistPigments();
                updatePaintButtonUI();
                updatePigmentsUI();
              });
              buyCharges?.addEventListener('click', async () => {
                const qty = Math.max(1, parseInt(chgQty.value || '1', 10) || 1);
                const cost = qty * CHARGES_COST;
                if (USER_PIGMENTS < cost) return;
                USER_PIGMENTS -= cost;
                USER_CHARGES += qty * CHARGES_UNIT; // allow over capacity
                await supabase?.from('user_paints').update({ charges: USER_CHARGES }).eq('user_id', USER_ID);
                await persistPigments();
                updatePaintButtonUI();
                updatePigmentsUI();
              });

              // Border purchase - Pigments
              const buyBorderPigments = document.getElementById('buyBorderPigments');
              buyBorderPigments?.addEventListener('click', async () => {
                const width = parseInt(borderWidth.value || '10', 10) || 10;
                const height = parseInt(borderHeight.value || '10', 10) || 10;
                const cost = calculateBorderCostPigments(width, height);
                if (USER_PIGMENTS < cost) return;
                
                // Deduct pigments (border functionality to be implemented)
                USER_PIGMENTS -= cost;
                await persistPigments();
                updatePigmentsUI();
                updateStoreButtonsEnabled();
                
                // Show confirmation
                alert(`Border purchased with pigments! ${width}x${height} protection activated.`);
              });

              // Border purchase - USD
              const buyBorderUSD = document.getElementById('buyBorderUSD');
              buyBorderUSD?.addEventListener('click', async () => {
                const width = parseInt(borderWidth.value || '10', 10) || 10;
                const height = parseInt(borderHeight.value || '10', 10) || 10;
                const cost = calculateBorderCostUSD(width, height);
                
                // For now, show alert (Stripe integration to be implemented)
                alert(`USD payment not yet implemented. Cost would be $${cost.toFixed(2)} for ${width}x${height} border.`);
              });
            });

            // Paint action -> Supabase upsert/delete
            async function paintCell(gridX, gridY, color) {
              const cellKey = `${gridX},${gridY}`;
              const cell = paintedCells.get(cellKey);

              if (!supabase || !USER_ID) {
                showNotification('Storage not configured yet');
                return;
              }

              if (color === null) {
                  if (!cell) return; // nothing to erase
                  if (cell.owner !== USER_ID) {
                      showNotification('You can only delete your own paint.');
                      return;
                  }
                  // Delete row (RLS enforces ownership)
                  const { error } = await supabase
                    .from('paints')
                    .delete()
                    .eq('x', gridX)
                    .eq('y', gridY);
                  if (error) { console.error('Delete error', error); return; }
                  paintedCells.delete(cellKey);
              } else {
                  // Require charges for authenticated users
                  if (USER_ID) {
                    if (USER_CHARGES <= 0) { showNotification('No more charges'); return; }
                  }
                  if (paintedCells.size >= MAX_CELLS && !paintedCells.has(cellKey)) {
                      showNotification();
                      return;
                  }
                  // If repainting a cell we already own:
                  let spendCharge = true;
                  if (cell && USER_ID && cell.owner === USER_ID) {
                    // If color is unchanged, skip any write and do not spend
                    if (cell.color === color) {
                      updatePaintButtonUI();
                      return;
                    }
                    // Allow color change without spending a charge
                    spendCharge = false;
                  }
                  const { error } = await supabase
                    .from('paints')
                    .upsert([{ x: gridX, y: gridY, color, owner: USER_ID, owner_name: USER_NAME, owner_avatar: USER_AVATAR }], { onConflict: 'x,y' });
                  if (error) { console.error('Upsert error', error); return; }
                  paintedCells.set(cellKey, { color, owner: USER_ID, owner_name: USER_NAME, owner_avatar: USER_AVATAR });
                  // Spend a charge if signed-in
                  if (USER_ID && spendCharge) {
                    const prevCharges = USER_CHARGES;
                    USER_CHARGES = Math.max(0, USER_CHARGES - 1);
                    // Start cooldown only when charges drop below capacity; clear if still >= capacity
                    lastRefillAt = (USER_CHARGES < USER_CAPACITY) ? Date.now() : null;
                    updatePaintButtonUI();
                    // Persist spend
                    await supabase.from('user_paints').update({
                      charges: USER_CHARGES,
                      last_refill_at: lastRefillAt ? new Date(lastRefillAt).toISOString() : null,
                      capacity: USER_CAPACITY
                    }).eq('user_id', USER_ID);
                  }
              }
              updatePaintedCellsDisplay();
              updateCellCounter();
            }
            const map = new maplibregl.Map({
                container: 'map',
                style: 'https://api.maptiler.com/maps/0198b6c2-2bd8-73e7-8d52-98bec753acb5/style.json?key=cnLd5cDF8MjR4DD1YOHi',
                center: [120.75754, 13.89790],
                zoom: 7.3,
                dragRotate: false
            });



        const CELL_SIZE_METERS = 20.0375; // 20.0375m × 20.0375m cells (exactly 2,000,000 × 2,000,000 cells worldwide)
        const HOVER_THRESHOLD = 4000; // Show hover when viewport has 4000x4000 cells or fewer
        
        
        // Painting system variables
        const PAINTING_THRESHOLD = 1000; // Only allow painting when visible cells <= 1000x1000
        const MAX_CELLS = 10000; // Maximum number of cells that can be painted
        let currentHoveredCell = null;
        let gridVisible = false;
        let isPaintingEnabled = false;
        let isPaintMode = false; // User must enable paint mode via paint button
        let selectedColor = '#FF4500'; // Default color
        let isSpacePressed = false; // Track if spacebar is held down
        let isRightMouseDown = false; // Track if right mouse button is held down
        let defaultNotificationText = null; // Store default notification text
        let lastZoomNoticeTime = 0; // throttle zoom-out notices
        const ZOOM_NOTICE_COOLDOWN = 1500; // ms
        let lastSelectedCell = null; // Remember last painted/selected cell
        let isAutoZooming = false; // Prevent recursive zoom triggers
        let hasAutoZoomedThisSession = false; // Only auto-zoom once per palette open
        
        // Color palette (expanded for equal rows)
        const colorPalette = [
            '#6D001A', '#BE0039', '#FF4500', '#FFA800', '#FFD635', '#FFF8B8', '#00A368', '#00CC78',
            '#7EED56', '#00756F', '#009EAA', '#00CCC0', '#2450A4', '#3690EA', '#51E9F4', '#493AC1',
            '#6A5CFF', '#811E9F', '#B44AC0', '#FF3881', '#FF99AA', '#6D482F', '#9C6926', '#FFB470',
            '#000000', '#515252', '#898D90', '#D4D7D9', '#FFFFFF', '#FF6B6B', '#4ECDC4', '#45B7D1',
            '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9', '#F8C471'
        ];

        // Convert geographic coordinates (EPSG:4326) to Web Mercator (EPSG:3857)
        function toWebMercator(lng, lat) {
            const x = lng * 20037508.34 / 180;
            const y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
            const yMercator = y * 20037508.34 / 180;
            return { x: x, y: yMercator };
        }

        // Convert Web Mercator (EPSG:3857) to geographic coordinates (EPSG:4326)
        function fromWebMercator(x, y) {
            const lng = x * 180 / 20037508.34;
            const lat = Math.atan(Math.exp(y * Math.PI / 20037508.34)) * 2 - Math.PI / 2;
            const latDegrees = lat * 180 / Math.PI;
            return { lng: lng, lat: latDegrees };
        }

        // Convert screen coordinates to grid coordinates (normalized to 0-1,999,999 range)
        function screenToGrid(screenX, screenY) {
            const mapPoint = map.unproject([screenX, screenY]);
            const mercatorPoint = toWebMercator(mapPoint.lng, mapPoint.lat);
            
            // Convert to normalized grid coordinates (0 to 1,999,999)
            // Web Mercator range: -20037508.34 to +20037508.34 meters
            const normalizedX = Math.floor((mercatorPoint.x + 20037508.34) / CELL_SIZE_METERS);
            const normalizedY = Math.floor((mercatorPoint.y + 20037508.34) / CELL_SIZE_METERS);
            
            // Clamp to valid range
            const gridX = Math.max(0, Math.min(1999999, normalizedX));
            const gridY = Math.max(0, Math.min(1999999, normalizedY));
            
            return { x: gridX, y: gridY };
        }

        // Convert grid coordinates to geographic coordinates (from normalized 0-1,999,999 range)
        function gridToGeo(gridX, gridY) {
            // Convert normalized grid coordinates back to EPSG:3857 meters
            // Web Mercator range: -20037508.34 to +20037508.34 meters
            const mercatorX = (gridX * CELL_SIZE_METERS) - 20037508.34;
            const mercatorY = (gridY * CELL_SIZE_METERS) - 20037508.34;
            
            // Convert back to EPSG:4326
            const geoPoint = fromWebMercator(mercatorX, mercatorY);
            return [geoPoint.lng, geoPoint.lat];
        }

        // Get grid cell size in meters (always 2m × 2m)
        function getGridCellSize() {
            return { meters: CELL_SIZE_METERS };
        }

        // Calculate how many grid cells are visible in the current viewport
        function getVisibleGridCells() {
            const bounds = map.getBounds();
            
            // Convert bounds to EPSG:3857
            const swMercator = toWebMercator(bounds.getWest(), bounds.getSouth());
            const neMercator = toWebMercator(bounds.getEast(), bounds.getNorth());
            
            // Convert to normalized grid coordinates (0 to 1,999,999)
            const startGridX = Math.floor((swMercator.x + 20037508.34) / CELL_SIZE_METERS);
            const endGridX = Math.ceil((neMercator.x + 20037508.34) / CELL_SIZE_METERS);
            const startGridY = Math.floor((swMercator.y + 20037508.34) / CELL_SIZE_METERS);
            const endGridY = Math.ceil((neMercator.y + 20037508.34) / CELL_SIZE_METERS);
            
            const cellsX = endGridX - startGridX;
            const cellsY = endGridY - startGridY;
            
            return { x: cellsX, y: cellsY };
        }

        // Generate grid lines for the current viewport
        function generateGridLines() {
            const bounds = map.getBounds();
            
            // Convert bounds to EPSG:3857
            const swMercator = toWebMercator(bounds.getWest(), bounds.getSouth());
            const neMercator = toWebMercator(bounds.getEast(), bounds.getNorth());
            
            // Convert to normalized grid coordinates (0 to 1,999,999)
            const startGridX = Math.floor((swMercator.x + 20037508.34) / CELL_SIZE_METERS);
            const endGridX = Math.ceil((neMercator.x + 20037508.34) / CELL_SIZE_METERS);
            const startGridY = Math.floor((swMercator.y + 20037508.34) / CELL_SIZE_METERS);
            const endGridY = Math.ceil((neMercator.y + 20037508.34) / CELL_SIZE_METERS);
            
            const features = [];
            
            // Generate vertical lines (using normalized grid coordinates)
            for (let x = startGridX; x <= endGridX; x++) {
                // Convert normalized grid coordinate back to EPSG:3857 meters
                const mercatorX = (x * CELL_SIZE_METERS) - 20037508.34;
                const geoPoint1 = fromWebMercator(mercatorX, swMercator.y);
                const geoPoint2 = fromWebMercator(mercatorX, neMercator.y);
                
                features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: [
                            [geoPoint1.lng, geoPoint1.lat],
                            [geoPoint2.lng, geoPoint2.lat]
                        ]
                    },
                    properties: { gridX: x, type: 'vertical' }
                });
            }
            
            // Generate horizontal lines (using normalized grid coordinates)
            for (let y = startGridY; y <= endGridY; y++) {
                // Convert normalized grid coordinate back to EPSG:3857 meters
                const mercatorY = (y * CELL_SIZE_METERS) - 20037508.34;
                const geoPoint1 = fromWebMercator(swMercator.x, mercatorY);
                const geoPoint2 = fromWebMercator(neMercator.x, mercatorY);
                
                features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: [
                            [geoPoint1.lng, geoPoint1.lat],
                            [geoPoint2.lng, geoPoint2.lat]
                        ]
                    },
                    properties: { gridY: y, type: 'horizontal' }
                });
            }
            
            return features;
        }

        // Generate hover cell polygon
        function generateHoverCell(gridX, gridY) {
            // Convert normalized grid coordinates to EPSG:3857 meters
            const mercatorX1 = (gridX * CELL_SIZE_METERS) - 20037508.34;
            const mercatorY1 = (gridY * CELL_SIZE_METERS) - 20037508.34;
            const mercatorX2 = ((gridX + 1) * CELL_SIZE_METERS) - 20037508.34;
            const mercatorY2 = ((gridY + 1) * CELL_SIZE_METERS) - 20037508.34;
            
            // Convert corners back to EPSG:4326
            const corner1 = fromWebMercator(mercatorX1, mercatorY1);
            const corner2 = fromWebMercator(mercatorX2, mercatorY1);
            const corner3 = fromWebMercator(mercatorX2, mercatorY2);
            const corner4 = fromWebMercator(mercatorX1, mercatorY2);
            
            return {
                type: 'Feature',
                geometry: {
                    type: 'Polygon',
                    coordinates: [[
                        [corner1.lng, corner1.lat],
                        [corner2.lng, corner2.lat],
                        [corner3.lng, corner3.lat],
                        [corner4.lng, corner4.lat],
                        [corner1.lng, corner1.lat]
                    ]]
                },
                properties: { gridX, gridY }
            };
        }

        // Update grid visibility based on viewport
        function updateGridVisibility() {
            const visibleCells = getVisibleGridCells();
            const shouldShowGrid = visibleCells.x <= HOVER_THRESHOLD && visibleCells.y <= HOVER_THRESHOLD;
            
            if (shouldShowGrid !== gridVisible) {
                gridVisible = shouldShowGrid;
                
                if (gridVisible) {
                    // Only show hover layer (grid lines remain hidden)
                    if (map.getLayer('grid-hover')) {
                        map.setLayoutProperty('grid-hover', 'visibility', 'visible');
                    }
                } else {
                    // Hide hover layer
                    if (map.getLayer('grid-hover')) {
                        map.setLayoutProperty('grid-hover', 'visibility', 'none');
                    }
                    // Clear hover
                    if (currentHoveredCell) {
                        map.getSource('grid-hover').setData({
                            type: 'FeatureCollection',
                            features: []
                        });
                        currentHoveredCell = null;
                    }
                }
            }
        }

        // Update grid data
        function updateGrid() {
            if (!gridVisible) return;
            
            // Grid lines are not rendered, so we don't need to update them
            // Only hover functionality is active
        }

        // Calculate wrapped coordinates (0-3999 range)
        function getWrappedCoordinates(worldX, worldY) {
            const displayX = worldX % 4000;
            const displayY = worldY % 4000;
            return { x: displayX, y: displayY };
        }
        
        // ...existing code...
        
        function getCellColor(gridX, gridY) {
                const cellKey = `${gridX},${gridY}`;
                const cell = paintedCells.get(cellKey);
                return cell ? cell.color : null;
        }
        
        function updatePaintedCellsDisplay() {
                if (!map.getSource('painted-cells')) return;
                const features = [];
                paintedCells.forEach((cell, cellKey) => {
                    const [x, y] = cellKey.split(',').map(Number);
                    const cellFeature = generateHoverCell(x, y);
                    cellFeature.properties.color = cell.color;
                    features.push(cellFeature);
                });
                map.getSource('painted-cells').setData({
                    type: 'FeatureCollection',
                    features: features
                });
        }
        
        function updateCellCounter() {
            // No number needed, just keep the button text as 'Paint'
        }
        
        function showNotification(message) {
            // Notifications disabled: no-op
            return;
        }
        
        function checkPaintingEnabled() {
            const visibleCells = getVisibleGridCells();
            isPaintingEnabled = visibleCells.x <= PAINTING_THRESHOLD && visibleCells.y <= PAINTING_THRESHOLD;
            return isPaintingEnabled;
        }

        // Check if the color palette is currently visible
        function isPaletteVisible() {
            const paletteEl = document.getElementById('colorPalette');
            return !!paletteEl && paletteEl.classList.contains('visible');
        }

        // Get cell center lng/lat for a grid cell
        function getCellCenterLngLat(gridX, gridY) {
            const [lng, lat] = gridToGeo(gridX + 0.5, gridY + 0.5);
            return [lng, lat];
        }

        // Auto-zoom to target cell so viewport shows roughly targetCells x targetCells
        function autoZoomToCell(gridX, gridY, targetCells = 60) {
            const center = getCellCenterLngLat(gridX, gridY);
            const currentZoom = map.getZoom();
            const visibleCells = getVisibleGridCells();
            const ratioX = visibleCells.x / targetCells;
            const ratioY = visibleCells.y / targetCells;
            const worstRatio = Math.max(ratioX, ratioY);
            const delta = Math.ceil(Math.log2(Math.max(worstRatio, 1)));
            const maxZoom = typeof map.getMaxZoom === 'function' ? map.getMaxZoom() : 22;
            const targetZoom = Math.min(currentZoom + delta, maxZoom);

            isAutoZooming = true;
            map.flyTo({ center: center, zoom: targetZoom, duration: 800 });
            map.once('moveend', () => {
                isAutoZooming = false;
            });
        }

        // Handle mouse move for hover
        function handleMouseMove(e) {
            if (!gridVisible) return;
            
            const gridCoords = screenToGrid(e.point.x, e.point.y);
            
            // Get wrapped coordinates for display (0-3999 range)
            const wrappedCoords = getWrappedCoordinates(gridCoords.x, gridCoords.y);
            
            // No bottom-left coordinate display
            
            // Check if painting is enabled (zoom level check)
            checkPaintingEnabled();
            
            // Only highlight cells when zoomed in enough (visible area <= 4000 × 4000 cells)
            const visibleCells = getVisibleGridCells();
            const shouldHighlight = visibleCells.x <= 4000 && visibleCells.y <= 4000;
            
            if (shouldHighlight) {
                // Update hover cell (still using full world coordinates for rendering)
                if (currentHoveredCell?.x !== gridCoords.x || currentHoveredCell?.y !== gridCoords.y) {
                    currentHoveredCell = { x: gridCoords.x, y: gridCoords.y };
                    
                    const hoverCell = generateHoverCell(gridCoords.x, gridCoords.y);
                    map.getSource('grid-hover').setData({
                        type: 'FeatureCollection',
                        features: [hoverCell]
                    });
                    
                    // Swipe paint when space is held down (only when palette is visible, a cell is highlighted, and <= 1000x1000 visible cells)
                    if (isSpacePressed && isPaintingEnabled && isPaletteVisible() && currentHoveredCell) {
                        const vc = getVisibleGridCells();
                        if (vc.x <= PAINTING_THRESHOLD && vc.y <= PAINTING_THRESHOLD) {
                            paintCell(gridCoords.x, gridCoords.y, selectedColor);
                        }
                    }
                    
                    // Swipe delete when right mouse is held down (only when palette is visible, a cell is highlighted, and <= 1000x1000 visible cells)
                    if (isRightMouseDown && isPaintingEnabled && isPaletteVisible() && currentHoveredCell) {
                        const vc = getVisibleGridCells();
                        if (vc.x <= PAINTING_THRESHOLD && vc.y <= PAINTING_THRESHOLD) {
                            paintCell(gridCoords.x, gridCoords.y, null);
                        }
                    }
                }
            } else {
                // Clear hover when zoomed out too far
                if (currentHoveredCell) {
                    map.getSource('grid-hover').setData({
                        type: 'FeatureCollection',
                        features: []
                    });
                    currentHoveredCell = null;
                }
            }
        }

        // Handle mouse leave
        function handleMouseLeave() {
            if (currentHoveredCell) {
                map.getSource('grid-hover').setData({
                    type: 'FeatureCollection',
                    features: []
                });
                currentHoveredCell = null;
            }
            // Reset mouse button states when leaving map
            isRightMouseDown = false;
        }
        
        // Handle mouse clicks for painting
        function handleMouseClick(e) {
            // Determine grid coordinates from current hover or click location
            const gridCoords = currentHoveredCell || screenToGrid(e.point.x, e.point.y);

            // If palette is not visible, show pixel info box and do nothing else
            if (!isPaletteVisible()) {
                // Only allow selection when viewport shows <= 4000 x 4000 cells (same as hover highlight)
                const visibleCells = getVisibleGridCells();
                const canSelect = visibleCells.x <= HOVER_THRESHOLD && visibleCells.y <= HOVER_THRESHOLD;
                if (!canSelect) {
                    const pixelInfo = document.getElementById('pixelInfo');
                    if (pixelInfo) pixelInfo.style.display = 'none';
                    // Show notice to zoom in
                    showNotification('Zoom in to select a pixel');
                    return;
                }
                const wrapped = getWrappedCoordinates(gridCoords.x, gridCoords.y);
                // Pass both world and display coordinates so we can look up owner correctly
                showPixelInfo(gridCoords.x, gridCoords.y, wrapped.x, wrapped.y);
                return;
            }

            // Palette is visible; enforce painting rules based on visible cells
            const vc = getVisibleGridCells();

            // > 4000 x 4000: block and notify
            if (vc.x > 4000 || vc.y > 4000) {
                showNotification('Zoom in to paint');
                return;
            }

            // Between 1000 and 4000: auto-zoom to ~100 x 100 at the target cell, do not paint yet
            if (vc.x > 1000 || vc.y > 1000) {
                autoZoomToCell(gridCoords.x, gridCoords.y, 100);
                return;
            }

            // Only allow painting if a cell is highlighted (hover active)
            if (!currentHoveredCell) return;

            if (e.originalEvent.button === 0) { // Left click - paint
                paintCell(gridCoords.x, gridCoords.y, selectedColor);
            } else if (e.originalEvent.button === 2) { // Right click - delete
                paintCell(gridCoords.x, gridCoords.y, null);
            }

            // Remember last selected cell (no extra auto-zoom here; painting allowed at <= 2000)
            lastSelectedCell = { x: gridCoords.x, y: gridCoords.y };
        }
        
        // Prevent context menu on right click
        function handleContextMenu(e) {
            e.preventDefault();
        }
        
        // Handle mouse down for swipe deletion
        function handleMouseDown(e) {
            if (e.originalEvent.button === 2) { // Right mouse button
                isRightMouseDown = true;
            }
        }
        
        // Handle mouse up for swipe deletion
        function handleMouseUp(e) {
            if (e.originalEvent.button === 2) { // Right mouse button
                isRightMouseDown = false;
            }
        }

        // Initialize grid when map loads
        map.on('load', () => {
            console.log('Map loaded successfully');
            
            // Add grid lines source and layer
            map.addSource('grid-lines', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });
            
            map.addLayer({
                id: 'grid-lines',
                type: 'line',
                source: 'grid-lines',
                paint: {
                    'line-color': 'rgba(255, 255, 255, 0.3)',
                    'line-width': 1
                },
                layout: {
                    visibility: 'none'
                }
            });
            
            // Add grid hover source and layer
            map.addSource('grid-hover', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });
            
            map.addLayer({
                id: 'grid-hover',
                type: 'fill',
                source: 'grid-hover',
                paint: {
                    'fill-color': 'rgba(255, 255, 255, 0.3)',
                    'fill-outline-color': 'rgba(0, 0, 0, 0.8)'
                },
                layout: {
                    visibility: 'none'
                }
            });
            
            // Add painted cells source and layer
            map.addSource('painted-cells', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                },
                // Ensure tiny polygons are not simplified away at low zooms
                tolerance: 0
            });

            map.addLayer({
                id: 'painted-cells',
                type: 'fill',
                source: 'painted-cells',
                paint: {
                    'fill-color': ['get', 'color'],
                    'fill-opacity': 1.0,
                    'fill-outline-color': 'transparent'
                },
                layout: {
                    visibility: 'visible'
                }
            });

            // Render any preloaded paints now that the source exists
            updatePaintedCellsDisplay();

            // Initial grid update
            updateGridVisibility();
            updateGrid();
            // Ensure painted layer visibility respects 4000x4000 threshold on load
            updatePaintedCellsVisibility();
            // Update zoom hint visibility on load
            updateZoomHintVisibility();
        });

        // Toggle painted layer visibility depending on visible grid cells
        function updatePaintedCellsVisibility() {
            if (!map.getLayer('painted-cells')) return;
            const vc = getVisibleGridCells();
            const visible = vc.x <= 4000 && vc.y <= 4000;
            const current = map.getLayoutProperty('painted-cells', 'visibility');
            const desired = visible ? 'visible' : 'none';
            if (current !== desired) {
                map.setLayoutProperty('painted-cells', 'visibility', desired);
            }
        }

        // Show/hide zoom hint button when viewport exceeds 4000 x 4000 cells
        function updateZoomHintVisibility() {
            const el = document.getElementById('zoomHint');
            if (!el) return;
            const vc = getVisibleGridCells();
            const tooMany = vc.x > 4000 || vc.y > 4000;
            el.style.display = tooMany ? 'block' : 'none';
        }

        // Zoom so that the larger dimension shows exactly 4000 cells (with slight epsilon to avoid rounding flicker)
        function zoomToTargetVisibleCells(target = 4000) {
            const vc = getVisibleGridCells();
            const ratioX = vc.x / target;
            const ratioY = vc.y / target;
            const worstRatio = Math.max(ratioX, ratioY);
            if (worstRatio <= 1) return; // already at or below target
            const currentZoom = map.getZoom();
            const delta = Math.log2(worstRatio);
            const epsilon = 0.02; // nudge to ensure <= target after rounding
            const targetZoom = Math.min(currentZoom + delta + epsilon, typeof map.getMaxZoom === 'function' ? map.getMaxZoom() : 22);
            map.easeTo({ zoom: targetZoom, duration: 800 });
        }

        map.on('zoom', () => {
            updateGridVisibility();
            updateGrid();
            updatePaintedCellsVisibility();
            updateZoomHintVisibility();
            // Throttled notice when zoomed out beyond painting capability
            const vc = getVisibleGridCells();
            if (vc.x > 4000 || vc.y > 4000) {
                const now = Date.now();
                if (now - lastZoomNoticeTime > ZOOM_NOTICE_COOLDOWN) {
                    showNotification('Zoomed out too far to paint. Zoom in.');
                    lastZoomNoticeTime = now;
                }
            }
        });

        // Also update on move to reflect viewport changes without zoom change
        map.on('move', () => {
            updatePaintedCellsVisibility();
            updateZoomHintVisibility();
        });

        // After interactions settle, re-evaluate to avoid threshold flicker
        map.on('moveend', () => {
            updatePaintedCellsVisibility();
            updateZoomHintVisibility();
        });

        // Handle window/map resize which affects visible cell count
        map.on('resize', () => {
            updatePaintedCellsVisibility();
            updateZoomHintVisibility();
        });

        // Wire up zoom hint button
        document.addEventListener('DOMContentLoaded', () => {
            const btn = document.getElementById('zoomHintBtn');
            if (btn) {
                btn.addEventListener('click', () => zoomToTargetVisibleCells(4000));
            }
        });

        map.on('mousemove', handleMouseMove);
        map.on('mouseleave', handleMouseLeave);
        map.on('click', handleMouseClick);
        map.on('contextmenu', handleContextMenu);
        map.on('mousedown', handleMouseDown);
        map.on('mouseup', handleMouseUp);

        // Keyboard event listeners for spacebar swipe painting
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !isSpacePressed) {
                e.preventDefault(); // Prevent page scrolling
                isSpacePressed = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                isSpacePressed = false;
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        let searchTimeout;

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }

            // Hide results if query is empty
            if (query.length === 0) {
                searchResults.style.display = 'none';
                return;
            }

            // Debounce search requests
            searchTimeout = setTimeout(() => {
                searchPlaces(query);
            }, 300);
        });

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                searchResults.style.display = 'none';
            }
        });

        async function searchPlaces(query) {
            try {
                // Show loading state
                searchResults.innerHTML = '<div class="loading">Searching...</div>';
                searchResults.style.display = 'block';

                // Use MapTiler Geocoding API
                const response = await fetch(
                    `https://api.maptiler.com/geocoding/${encodeURIComponent(query)}.json?key=cnLd5cDF8MjR4DD1YOHi&limit=5`
                );

                if (!response.ok) {
                    throw new Error('Geocoding request failed');
                }

                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    displaySearchResults(data.features);
                } else {
                    searchResults.innerHTML = '<div class="loading">No places found</div>';
                }
            } catch (error) {
                console.error('Search error:', error);
                searchResults.innerHTML = '<div class="loading">Search failed</div>';
            }
        }

        function displaySearchResults(features) {
            searchResults.innerHTML = '';
            
            features.forEach(feature => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'search-result';
                
                const placeName = document.createElement('div');
                placeName.className = 'place-name';
                placeName.textContent = feature.place_name || feature.text || 'Unknown location';
                
                const placeDetails = document.createElement('div');
                placeDetails.className = 'place-details';
                placeDetails.textContent = feature.context ? 
                    feature.context.map(ctx => ctx.text).join(', ') : 
                    `${feature.center[1].toFixed(4)}, ${feature.center[0].toFixed(4)}`;
                
                resultDiv.appendChild(placeName);
                resultDiv.appendChild(placeDetails);
                
                resultDiv.addEventListener('click', () => {
                    // Fly to the selected location
                    map.flyTo({
                        center: feature.center,
                        zoom: Math.max(map.getZoom(), 10),
                        duration: 2000
                    });
                    
                    // Hide search results
                    searchResults.style.display = 'none';
                    searchInput.value = feature.place_name || feature.text || 'Unknown location';
                });
                
                searchResults.appendChild(resultDiv);
            });
            
            searchResults.style.display = 'block';
        }

        map.on('error', (e) => {
            console.error('Map error:', e);
        });
        
        // Initialize palette functionality
        function initializePalette() {
            const colorRow1 = document.getElementById('colorRow1');
            const colorRow2 = document.getElementById('colorRow2');
            const paletteCloseButton = document.getElementById('paletteClose');
            const paintButton = document.getElementById('paintButton');
            const pixelInfo = document.getElementById('pixelInfo');
            const pixelInfoText = document.getElementById('pixelInfoText');
            const pixelClose = document.getElementById('pixelClose');
            const pixelOwnerRow = document.getElementById('pixelOwnerRow');
            const pixelOwnerText = document.getElementById('pixelOwnerText');
            const pixelOwnerAvatar = document.getElementById('pixelOwnerAvatar');
            const pixelActionPaint = document.getElementById('pixelActionPaint');
            const pixelActionFavorite = document.getElementById('pixelActionFavorite');
            const pixelActionShare = document.getElementById('pixelActionShare');
            
            // Generate color swatches in two rows
            colorRow1.innerHTML = '';
            colorRow2.innerHTML = '';
            
            colorPalette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;
                
                // Mark default color as selected
                if (color === selectedColor) {
                    swatch.classList.add('selected');
                }
                
                swatch.addEventListener('click', () => {
                    // Remove previous selection
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    // Select new color
                    swatch.classList.add('selected');
                    selectedColor = color;
                });
                
                // Distribute colors equally between two rows (20 colors per row)
                if (index < 20) {
                    colorRow1.appendChild(swatch);
                } else {
                    colorRow2.appendChild(swatch);
                }
            });
            
            // Toggle color palette when paint button is clicked and enable paint mode
            paintButton.addEventListener('click', () => {
                if (!USER_ID) { // require sign-in first
                    showAuthPrompt();
                    return;
                }
                const colorPalette = document.getElementById('colorPalette');
                colorPalette.classList.toggle('visible');
                isPaintMode = true;
                if (pixelInfo) pixelInfo.style.display = 'none';
                paintButton.style.display = 'flex';
                if (colorPalette.classList.contains('visible')) {
                    hasAutoZoomedThisSession = false;
                }
            });
            
            // Close palette with X button
            paletteCloseButton.addEventListener('click', () => {
                document.getElementById('colorPalette').classList.remove('visible');
            });

            // Close pixel info and bring back paint button
            pixelClose.addEventListener('click', () => {
                pixelInfo.style.display = 'none';
                paintButton.style.display = 'flex';
            });

            // Pixel action buttons
            if (pixelActionPaint) {
              pixelActionPaint.addEventListener('click', () => {
                // Open the palette just like clicking the main paint button
                paintButton.click();
              });
            }
            if (pixelActionFavorite) {
              pixelActionFavorite.addEventListener('click', () => {
                try {
                  const txt = pixelInfoText?.textContent || '';
                  const m = txt.match(/Pixel:\s*(\d+),\s*(\d+)/);
                  if (m) {
                    const fav = JSON.parse(localStorage.getItem('favorites')||'[]');
                    fav.push({ x: Number(m[1]), y: Number(m[2]), t: Date.now() });
                    localStorage.setItem('favorites', JSON.stringify(fav));
                    showNotification('Added to favorites');
                  }
                } catch {}
              });
            }
            if (pixelActionShare) {
              pixelActionShare.addEventListener('click', async () => {
                const txt = pixelInfoText?.textContent || '';
                const m = txt.match(/Pixel:\s*(\d+),\s*(\d+)/);
                if (!m) return;
                const url = new URL(window.location.href);
                url.searchParams.set('x', m[1]);
                url.searchParams.set('y', m[2]);
                try {
                  await navigator.clipboard.writeText(url.toString());
                  showNotification('Link copied');
                } catch {
                  showNotification('Copy failed');
                }
              });
            }

            // Helper to show pixel info in center-bottom and hide paint button
            window.showPixelInfo = function(worldX, worldY, displayX, displayY) {
                if (!pixelInfo || !pixelInfoText) return;
                // Use world coords for storage lookup
                const key = `${worldX},${worldY}`;
                const cell = paintedCells.get(key);
                // Show wrapped/display coords in UI
                pixelInfoText.textContent = `Pixel: ${displayX}, ${displayY}`;
                // Owner row
                if (!cell) {
                  // Hide the owner row entirely for unpainted cells
                  if (pixelOwnerRow) pixelOwnerRow.style.display = 'none';
                  if (pixelOwnerAvatar) pixelOwnerAvatar.style.display = 'none';
                } else {
                  const ownerLabel = (cell.owner_name && cell.owner_name.trim()) ? cell.owner_name : shortUser(cell.owner);
                  if (pixelOwnerText) pixelOwnerText.textContent = ownerLabel;
                  if (pixelOwnerRow) pixelOwnerRow.style.display = 'flex';
                  if (cell.owner_avatar && pixelOwnerAvatar) {
                    pixelOwnerAvatar.src = cell.owner_avatar; pixelOwnerAvatar.style.display = 'inline-block';
                  } else if (pixelOwnerAvatar) {
                    pixelOwnerAvatar.style.display = 'none';
                  }
                }
                pixelInfo.style.display = 'block';
                paintButton.style.display = 'none';
            };
        }
        
        // Initialize palette when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializePalette();
            updateCellCounter(); // Initialize the cell counter
        });

        // Google Sign-In removed; using Supabase anonymous auth.
    </script>

</body></html>